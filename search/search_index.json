{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Hypermedia","text":"<p>A fully typed Python HTML Renderer with a focus on composability of elements. All html tags available with autocompletion for all the tags attributes. A perfect companion for htmx and ships with FastAPI integration.</p>"},{"location":"#showcase","title":"Showcase","text":"pythonfull(user=\"John Doe\").dump()partial().dump() views/index.py<pre><code>def base() -&gt; Element:  # (1)\n    \"\"\"Your base html document. Written once. Reused anywhere.\"\"\"\n    return Html(\n        Head(slot=\"head\"),\n        Body(\n            Header(slot=\"header\"),\n            Main(slot=\"content\"),\n            Footer(slot=\"footer\"),\n        ),\n    )\n\n\ndef user_header(user: str):\n    return Div(user, Button(\"log out\", hx_post=\"/logout\"))\n\n\ndef partial() -&gt; Element:\n    return Div(H1(\"Welcome\"), Paragraph(\"Lorem ipsum...\"))\n\n\ndef full(user: str | None) -&gt; Element:\n    html = base()\n\n    # add title:\n    html.extend(\"head\", Title(\"Welcome to test.com\"))\n\n    # If user is logged in add user header\n    if user:\n        html.extend(\"header\", user_header(user))\n\n    # Extend with index content\n    html.extend(\n        \"content\",\n        partial(),\n    )\n\n    return html\n</code></pre> <ol> <li>This function is usually placed in <code>commons.py</code> or similar since it will be used by all view files.</li> </ol> <pre><code>&lt;html&gt;\n\n&lt;head&gt;\n    &lt;title&gt;Welcome to test.com&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;!-- (1) --&gt;\n        &lt;div&gt;John Doe&lt;button hx-post='/logout'&gt;log out&lt;/button&gt;&lt;/div&gt;\n    &lt;/header&gt;\n    &lt;main&gt;\n        &lt;!-- (2) --&gt;\n        &lt;div&gt;\n            &lt;h1&gt;Welcome&lt;/h1&gt;\n            &lt;p&gt;Lorem ipsum...&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;&lt;/footer&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> <ol> <li>Base was extended with result from <code>user_header(user: str)</code> function because a user was logged in!</li> <li>This part is rendered by the <code>partial()</code> function.</li> </ol> <pre><code>&lt;div&gt;\n    &lt;h1&gt;Welcome&lt;/h1&gt;\n    &lt;p&gt;Lorem ipsum...&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"#why-use-hypermedia","title":"Why use Hypermedia","text":"<p>If the above example intrigues you then that should be more than enough to give <code>hypermedia</code> a go. </p> <p>Other reasons for hypermedia:</p> <ul> <li>You need to create html with Python</li> <li>You want to create html snippets and weave them together.</li> <li>You think HTMX makes a lot of sense.</li> <li>Html attributes? yes. Every html element have autocompletion for their specific attributes.</li> <li>Jinja? tired of not being able to use your types and models? hypermedia never leaves python land, so you keep it all!</li> <li>You want to make a website with FastAPI - <code>hypermedia</code> ships with special decorator for FastAPI</li> </ul>"},{"location":"#goal","title":"Goal","text":"<p>To make it easy to write a webapplication in python.</p>"},{"location":"#why","title":"Why","text":"<p>This was just the way we wanted to write html with python. We didn't want to have jinja files were we lost all typing and autocompletion from our python project. And we felt that existing solutions didn't do <code>composability</code> the way we wanted to do it. Especially with regards to working with <code>htmx</code> with partials and full pages.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Add issues, ask good questions. Come with good suggestions &lt;3</p> <p>check the contibuting section</p>"},{"location":"#installation","title":"Installation","text":"<p>Package is on pypi. Use <code>pip</code>, <code>poetry</code> or <code>uv</code> to install</p> <p><pre><code>pip install hypermedia\n</code></pre> <pre><code>poetry add hypermedia\n</code></pre> <pre><code>uv add hypermedia\n</code></pre></p> <p>What to do next? head over to the quickstart section!</p>"},{"location":"contributing/","title":"Contributing","text":"<p>The best thing that can be contributed with is bug reports and documentation.</p> <p>To help with documentation fork the repo, and run the mkdocs site with:</p> <pre><code>uv sync\n\nuv run mkdocs serve\n</code></pre> <p>Tip</p> <p>Add <code>--livereload</code> to enable autorefresh</p> <p>This starts up a server at localhost:8000 navigate there and start adding or editing the doc files in <code>/docs</code></p>"},{"location":"daisyui/","title":"CSS - DaisyUI, Tailwind","text":"<p>In this guide the folder my app is just called <code>server</code>, whenever it is used, replace it with your app folder. This is the folder that contains the <code>main.py</code>(normally) file that has the <code>app = FastAPI()</code> variable in it. We've highlighted where you need to do changes.</p>"},{"location":"daisyui/#1-download-and-setup-tailwind-cli","title":"1. Download and setup tailwind cli","text":"<p>DaisyUI has a quick setup that is easy to follow.</p> <p>https://daisyui.com/docs/install/standalone/</p> <p>This also downloads the daisyui mjs file and creates <code>input.css</code> and <code>output.css</code> files. You can just delete the <code>output.css</code> file for now.</p>"},{"location":"daisyui/#2-make-a-tailwind-setup-file","title":"2. Make a tailwind setup file","text":"<p>This fils should be in the root of your project folder with the name <code>input.css</code></p> <p>If you got one in step 1, just make sure it looks something like below.</p> <pre><code>@import \"tailwindcss\" source(\"./server\");\n\n@source not \"./tailwindcss\";\n@source not \"./daisyui{,*}.mjs\";\n\n@plugin \"./daisyui.mjs\" {\n  themes: cupcake;\n}\n</code></pre> <p>replace <code>\"./server\"</code> with the name of your app folder</p> <p>Tip</p> <p>You can change the theme to the one you like, just replace <code>cupcake</code> with a name you find in this list</p>"},{"location":"daisyui/#3-compile-the-new-tailwind-to-use","title":"3 Compile the new tailwind to use","text":"<pre><code>./tailwindcss -i ./input.css -o ./server/static/css/server.css\n</code></pre> <p>Note</p> <p>Change <code>server</code> with the name of your app. The folder that contains tha main.py that has the wsgi app variable.</p> <p>Tip</p> <p>add <code>-m</code> flag to minify the css output</p> <p>If that doesn't work try to make the tailwind file executable with:</p> <pre><code>chmod +x tailwindcss\n</code></pre> <p>If that doesnt work follow this guide and try again, try to figure it out and post an update with the fix or the issue at the issue tracker</p>"},{"location":"daisyui/#4-add-static-file-handler-to-the-fastapi-app","title":"4. Add static file handler to the FastAPI app","text":"<p>in <code>main.py</code> add the following, making sure to  change <code>server</code> with your app folders name first</p> <pre><code>app.mount(\"/static\", StaticFiles(directory=\"server/static/\"), name=\"static\")\n</code></pre>"},{"location":"daisyui/#5-add-the-script-tag-to-load-the-css-in-your-base-html","title":"5. Add the script tag to load the css in your base html.","text":"<pre><code>def get_base() -&gt; Element:\n    \"\"\"Create the base page.\"\"\"\n    return ElementList(\n        Doctype(),\n        Html(\n            Head(\n                Meta(charset=\"UTF-8\"),\n                Meta(\n                    name=\"viewport\",\n                    content=\"width=device-width, initial-scale=1.0\",\n                ),\n                Link(rel=\"stylesheet\", href=\"/static/css/server.css\"),\n                Title(\"Server - home\"),\n                slot=\"head\",\n            ),\n            Body(\n                Header(),\n                Main(id=\"main\", slot=\"main\")\n            ),\n            lang=\"no-nb\",\n            data_theme=\"cupcake\",  # type: ignore\n        ),\n    )\n</code></pre> <p>Change <code>/static/css/server.css</code> if you chose a different folder structure.</p> <p>Change the <code>cupcake</code> part of <code>data_theme=\"cupcake\"</code> to whichever theme you want.</p>"},{"location":"htmx/","title":"HTMX","text":""},{"location":"htmx/#the-concept","title":"The Concept","text":"<p>The core concept of HTMX is that we add event listeneres directly onto the html elements, when triggered htmx sends a request to the server, the server responds with HTML, and that we can choose with a CSS selector which part of the page will be updated with the HTML returned from the server.</p> <p>This means that we have 3 concepts to consider.</p> <ol> <li>A full refresh, or first visit should return the whole html doc</li> <li>A htmx request to a page should only update spesific concent, no need for header/menu/footer.</li> <li>A htmx request can be a simple item in a list</li> </ol> <p>Anything that is not the full html document is what we'll refer to as <code>partials</code> in hypermedia.</p>"},{"location":"htmx/#the-problem","title":"The Problem","text":"<p>The problem is that we need to differentiate if it's HTMX that called an endpoint for a <code>partial</code>, or if the user just navigated directly to it and needs the <code>whole page</code> back in the response.</p>"},{"location":"htmx/#the-solution","title":"The Solution","text":"<p>HTMX provides an <code>HX-Request</code> header that is always true. We can check for this header to know if it's an HTMX request or not.</p> <p>In hypermedia we've chosen to implement that check in a <code>@htmx</code> decorator for fastAPI. The decorator expects <code>partial</code> and optionally <code>full</code> arguments in the endpoint definition. These must be resolved by FastAPI's dependency injection system.</p> <p>Info</p> <p>I'm all for letting people use this with django, flask, tornado so feel free to make a PR for decorators for web frameworks.</p> <pre><code>from hypermedia.fastapi import htmx, full\n</code></pre> <p>The <code>partial</code> argument is a function that returns the partial HTML. The <code>full</code> argument is a function that needs to return the whole HTML, for example on first navigation or a refresh.</p> <p>Note</p> <p><code>partial</code> and <code>full</code> arguments needs to be wrapped in <code>Depends</code> so that the full function's dependencies are resolved! Hypermedia ships an extra <code>full</code> wrapper, which is basically just making the function lazily loaded. The <code>full</code> wrapper must be used, and the <code>@htmx</code> decorator will call the lazily wrapped function to get the full HTML page only when needed.</p> <pre><code>@router.get(\"\", response_class=HTMLResponse)\n@htmx\nasync def fruits(\n    request: Request,\n    partial: Annotated[Element, Depends(render_fruits_partial)],\n    full: Annotated[Element, Depends(full(render_fruits))],\n) -&gt; None:\n    \"\"\"Return the fruits page, partial or full.\"\"\"\n</code></pre>"},{"location":"htmx/#htmx-usage","title":"HTMX usage","text":"<p>Using htmx is very straight forward. And all htmx attributes are fully typed and will work with autocompletion.</p> <p>Note</p> <p>Since we can't use '-' in variable names and parameters all htmx attributes are written with underscore instead. ie: <code>hx-get</code> -&gt; <code>hx_get</code></p> <p>To make a button that does a request to /fruits and puts the returned html into the <code>&lt;main&gt;</code> element:</p> <pre><code>from hypermedia import Button\n\nButton(\"Fruits\", hx_get=\"/fruits\", hx_target=\"main\")\n</code></pre> <p>Hint</p> <p><code>\"main\"</code> will replace the contents of the <code>&lt;main&gt;</code> element. replace <code>\"main\"</code> with a css selector like <code>\"#body\"</code> to replace that instead.</p> <p>To make a div do a put update request to the fruit and take the returned html and replace itself. us target <code>\"this\"</code> This is very usefull for sending an update and have the server respond with the html for the new state (changed background color, new text/numbers). </p> <pre><code>from hypermedia import Div\n\nDiv(\"Banana\", hx_put=\"/fruits/banana/set-eaten\", hx_target=\"this\")\n</code></pre>"},{"location":"htmx/#setup-htmx-in-your-project","title":"Setup HTMX in your project","text":"<p>All we need to do is add a script tag in the head that points to htmx</p> <pre><code>from hypermedia import Script\n\nScript(\n    src=\"https://unpkg.com/htmx.org@2.0.0\",\n    integrity=\"sha384-wS5l5IKJBvK6sPTKa2WZ1js3d947pvWXbPJ1OmWfEuxLgeHcEbjUUA5i9V5ZkpCw\",\n    crossorigin=\"anonymous\",\n)\n</code></pre> <p>Here is a full example of a standard base with htmx added.</p> <pre><code>def base() -&gt; Element: \n    return ElementList(\n        Doctype(),\n        Html(\n            Head(\n                Title(\"My page\"),\n                Meta(charset=\"UTF-8\"),\n                Meta(name=\"viewport\", content=\"width=device-width, initial-scale=1.0\"),\n                Meta(name=\"mobile-web-app-capable\", content=\"yes\"),\n                slot=\"head\",\n            ),\n            Main(id=\"main\", slot=\"main\"),\n            Script(\n                src=\"https://unpkg.com/htmx.org@2.0.0\",\n                integrity=\"sha384-wS5l5IKJBvK6sPTKa2WZ1js3d947pvWXbPJ1OmWfEuxLgeHcEbjUUA5i9V5ZkpCw\",\n                crossorigin=\"anonymous\",\n            ),\n            slot=\"html\",\n            lan=\"en\",\n        ),\n    )\n</code></pre>"},{"location":"htmx/#htmx-settings","title":"Htmx settings","text":"<p>Here are good default settings that helps with common issues</p> <pre><code>htmx_config = {\n    \"defaultSwapStyle\": \"innerHTML\",\n    \"globalViewTransitions\": True,\n    \"history\": False,\n    \"refreshOnHistoryMiss\": True,\n    \"allowNestedOobSwaps\": True,\n    \"historyCacheSize\": 0,\n}\n</code></pre> <p>Add this to your header with the Meta tag:</p> <pre><code>Meta(name=\"htmx-config\", content=json.dumps(htmx_config)),\n</code></pre>"},{"location":"htmx/#vary-header","title":"Vary header","text":"<p>One unfortunate thing is how back navigation is handled, if the browser issues the back navigation, it believes the last request is what should be returned and that is often a htmx partial. To prevent this we can set up a middleware that assigns a <code>Vary</code> header. This tells the browser to treat the history differently based on what did the requests.</p> <pre><code>@app.middleware(\"http\")\nasync def add_vary_accept_header(  # type: ignore\n    request: Request,\n    call_next,\n) -&gt; Response:\n    \"\"\"Add the vary accept header.\n\n    This allows the browser to cache the responses based on caller,\n    which should prevent the browser from caching htmx responses as a full page\n    \"\"\"\n    response: Response = await call_next(request)\n    response.headers[\"Vary\"] = \"Accept\"\n    return response\n</code></pre>"},{"location":"htmx/#non-standard-htmx-attributes","title":"Non standard htmx attributes","text":"<p>Some of the htmx attributes would be a lot of work to map out, so in those cases you can replace both <code>:</code> and <code>-</code> with <code>_</code> and it should work</p> <p>The documentation specifies that all hx attributes can be written with all dashes. Because of that Hypermedia lets users write hx attributes with underscores and Hypermedia changes them to dashes for you.</p> <pre><code>from hypermedia import Div\n\nDiv(hx_on_click='alert(\"Making a request!\")')\n# &lt;div hx-on-click='alert(\"Making a request!\")'&gt;&lt;/div&gt;\n# Which is equivalent to:\n# &lt;div hx-on:click='alert(\"Making a request!\"'&gt;&lt;/div&gt;\n\nDiv(hx_on_htmx_before_request='alert(\"Making a request!\")')\n# &lt;div hx-on-htmx-before-request='alert(\"Making a request!\")'&gt;&lt;/div&gt;\n\n# shorthand version of above statement with double underscore\nDiv(hx_on__before_request='alert(\"Making a request!\")')\n# &lt;div hx-on--before-request='alert(\"Making a request!\")'&gt;&lt;/div&gt;\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>Package is on pypi. Use <code>uv</code>, <code>poetry</code> or <code>pip</code> to install</p> <pre><code>uv add hypermedia\n</code></pre> <pre><code>poetry add hypermedia\n</code></pre> <pre><code>pip install hypermedia\n</code></pre>"},{"location":"quickstart/#the-basics","title":"The Basics","text":"<p>All html tags can be imported directly like:</p> <pre><code>from hypermedia import Html, Body, Div, A\n</code></pre> <p>Tags are nested by adding children in the constructor:</p> <pre><code>from hypermedia import Html, Body, Div\n\nHtml(Body(Div(), Div()))\n</code></pre> <p>Add text to your tag:</p> <pre><code>from hypermedia import Div\n\nDiv(\"Hello world!\")\n</code></pre> <p>use <code>.dump()</code> to dump your Elements to html.</p> <pre><code>from hypermedia import Bold, Div\n\nDiv(\"Hello \", Bold(\"world!\")).dump()\n</code></pre> <p>outputs</p> <pre><code>&lt;div&gt;Hello &lt;b&gt;world!&lt;/b&gt;&lt;/div&gt;\n</code></pre>"},{"location":"quickstart/#composability-with-slots","title":"Composability with slots","text":"<pre><code>from hypermedia import Html, Body, Div, Menu, Header, Div, Ul, Li\n\nbase = Html(\n    Body(\n        Menu(slot=\"menu\"),\n        Header(\"my header\", slot=\"header\"),\n        Div(slot=\"content\"),\n    ),\n)\n\nmenu = Ul(Li(text=\"main\"))\ncontent = Div(text=\"Some content\")\n\nbase.extend(\"menu\", menu)\nbase.extend(\"content\", content)\n\nbase.dump()\n</code></pre> <p>output</p> <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;menu&gt;\n            &lt;ul&gt;&lt;li&gt;main&lt;/li&gt;&lt;/ul&gt;\n        &lt;/menu&gt;\n        &lt;header&gt;my header&lt;/header&gt;\n        &lt;div&gt;\n            &lt;div&gt;Some content&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;'\n</code></pre>"},{"location":"slots_and_extending/","title":"Slots and Extenting","text":"<p>Hypermedia comes lets you define slots where you want to be able to add, extend, later.</p>"},{"location":"slots_and_extending/#slot","title":"Slot","text":"<p>You can add a slot to any hypermedia <code>Element</code> you want</p>"},{"location":"fastapi/","title":"Hypermedia and FastAPI","text":"<p>Hypermedia can be used with any framework, but was created with FastAPI in mind and thus ships with some utility functions.</p> <p>In FastAPI you create function and decorate them to create routes. When FastAPI gets a request it looks for a function that is decorated with a path that matches the url. </p> <p>This section assumes you have read the htmx section of the documentation.</p>"},{"location":"fastapi/#returning-html-in-fastapi","title":"Returning html in FastAPI","text":"<pre><code>from fastapi import FastAPI\nfrom hypermedia import Div\n\napp = FastAPI()\n\n@app.get(\"\", response_class=HTMLResponse)\nasync def index(request: Request) -&gt; None:\n    \"\"\"Return an index page.\"\"\"\n    return Div(\"Hello world\").dump()\n</code></pre> <p>This is all you have to do. open <code>localhost:port</code> in your browser and you should get a page with the text <code>Hello world</code>.</p> <p>Notice the <code>.dump()</code></p> <p>If you are using <code>htmx</code> you can use the @htmx decorator to have hypermedia return only the partial when the endpoint receives an <code>htmx</code> request and the full page only when it isn't.</p> <pre><code>@app.get(\"\", response_class=HTMLResponse)\n@htmx\nasync def index(\n    request: Request,\n    partial: Annotated[Element, Depends(render_index_partial)],\n    full: Annoated[Element, Depends(full(render_index))],\n) -&gt; None:\n    \"\"\"Return the index of our page.\"\"\"\n    pass\n</code></pre> <pre><code>from hypermedia.fastapi import htmx, full\n</code></pre> <p>The <code>partial</code> argument is a function that returns the partial HTML. The <code>full</code> argument is a function that needs to return the whole HTML, for example on first navigation or a refresh.</p> <p>Note</p> <p><code>partial</code> and <code>full</code> arguments needs to be wrapped in <code>Depends</code> so that the full function's dependencies are resolved! Hypermedia ships an extra <code>full</code> wrapper, which is basically just making the function lazily loaded. The <code>full</code> wrapper must be used, and the <code>@htmx</code> decorator will call the lazily wrapped function to get the full HTML page when needed.</p> <p>Note: The following code is in FastAPI, but could have been anything. As long as you check for HX-Request and return partial/full depending on if it exists or not.</p> <pre><code>def render_base():\n    \"\"\"Return base HTML, used by all full renderers.\"\"\"\n    return ElementList(Doctype(), Body(slot=\"body\"))\n\n\ndef render_fruits_partial():\n    \"\"\"Return partial HTML.\"\"\"\n    return Div(Ul(Li(\"Apple\"), Li(\"Banana\"), Button(\"reload\", hx_get=\"/fruits\")))\n\n\ndef render_fruits():\n    \"\"\"Return base HTML extended with `render_fruits_partial`.\"\"\"\n    return render_base().extend(\"body\", render_fruits_partial())\n\n\n@router.get(\"/fruits\", response_class=HTMLResponse)\n@htmx\nasync def fruits(\n    request: Request,\n    partial: Element = Depends(render_fruits_partial),\n    full: Element = Depends(full(render_fruits)),\n) -&gt; None:\n    \"\"\"Return the fruits page, partial or full.\"\"\"\n    pass\n</code></pre> <p>That's it. Now we have separated the rendering from the endpoint definition and handled returning partials and full pages when needed. Doing a full refresh will render the whole page. Clicking the button will make a htmx request and only return the partial.</p> <p>What is so cool about this is that it works so well with FastAPI's dependency injection.</p>"},{"location":"fastapi/#really-making-use-of-dependency-injection","title":"Really making use of dependency injection","text":"<pre><code>fruits = {1: \"apple\", 2: \"orange\"}\n\ndef get_fruit(fruit_id: int = Path(...)) -&gt; str:\n    \"\"\"Get fruit ID from path and return the fruit.\"\"\"\n    return fruits[fruit_id]\n\ndef render_fruit_partial(\n    fruit: str = Depends(get_fruit),\n) -&gt; Element:\n    \"\"\"Return partial HTML.\"\"\"\n    return Div(fruit)\n\ndef render_fruit(\n    partial: Element = Depends(render_fruit_partial),\n):\n    return render_base().extend(\"content\", partial)\n\n@router.get(\"/fruits/{fruit_id}\", response_class=HTMLResponse)\n@htmx\nasync def fruit(\n    request: Request,\n    partial: Element = Depends(render_fruit_partial),\n    full: Element = Depends(full(render_fruit)),\n) -&gt; None:\n    \"\"\"Return the fruit page, partial or full.\"\"\"\n    pass\n</code></pre> <p>Here we do basically the same as the previous example, except that we make use of FastAPI's great dependency injection system. Notice the path of our endpoint has <code>fruit_id</code>. This is not used in the definition. However, if we look at our partial renderer, it depends on <code>get_fruit</code>, which is a function that uses FastAPI's <code>Path resolver</code>. The DI then resolves (basically calls) the fruit function, passes the result into our partial function, and we can use it as a value!</p> <p>This pattern with DI, Partials, and full renderers is what makes using FastAPI with HTMX worth it.</p> <p>In addition to this, one thing many are concerned about with HTMX is that since we serve HTML, there will be no way for another app/consumer to get a fruit in JSON. But the solution is simple:</p> <p>Because we already have a dependency that retrieves the fruit, we just need to add a new endpoint:</p> <pre><code>@router.get(\"/api/fruit/{fruit_id}\")\nasync def fruit(\n    request: Request,\n    fruit: str = Depends(get_fruit),\n) -&gt; str:\n    \"\"\"Return the fruit data.\"\"\"\n    return fruit\n</code></pre> <p>Notice we added <code>/api/</code> and just used DI to resolve the fruit and just returned it. Nice!</p>"}]}